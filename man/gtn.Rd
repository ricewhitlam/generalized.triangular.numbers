% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generalized_triangular_number.R
\name{gtn}
\alias{gtn}
\title{Compute the generalized triangular numbers}
\usage{
gtn(0, 10)
gtn(1, 10)
gtn(2, 10)
gtn(3, 10)
}
\arguments{
\item{z}{A length \code{1} \code{complex} indicating the dimension in which to calculate the sequence}

\item{n}{A length \code{1} \code{integer} indicating the desired index in the sequence - must be positive}

\item{sequence}{A length \code{1} \code{logical}. 
If \code{TRUE}, a length \code{n} \code{complex} will be returned: the first \code{n} generalized triangular numbers in dimension \code{z}.
If \code{FALSE}, a length \code{1} \code{complex} will be returned: the index \code{n} generalized triangular number in dimension \code{z}.
Defaults to \code{TRUE}.}
}
\value{
Depending on the value of \code{sequence}, either 
the first \code{n} generalized triangular numbers in dimension \code{z}
or the index \code{n} generalized triangular number in dimension \code{z}
}
\description{
The triangular numbers are 1,3,6,10,15,21... 
That is, the index \code{n} triangular number is the sum of the first \code{n} positive integers.
The sequence is named as such because it counts the number of dots in triangular
arrays with increasing numbers of rows. This sequence can be generalized by 
altering the dimension under consideration. The triangular numbers are the two 
dimensional case, but in three dimensions the tetrahedral numbers are obtained: 
1,4,10,20,35,56... In fact, the generalization can be made so extreme as to allow
a "dimension" equal to any complex number. In the case of numbers which are not 
positive integers, the dot-counting interpretation breaks down, but the sequence 
is still well-defined. \cr \cr
While these numbers are interesting in a pure sense,
one application is related to cumulative sums and differences.
If the cumulative sum is thought of as an operator with the difference being its
inverse operator, then iterated cumulative sums and differences of a vector \code{v}
can be computed by convolving with the appropriate vector of 
generalized triangular numbers. For example, this will compute the 
cumulative sum of \code{v} iterated \code{m} times: \cr \cr
\code{
foo <- function(v,m){ \cr
\verb{    }n <- length(v) \cr
\verb{    }pow.2 <- 2^(1+ceiling(log(n,2))) \cr
\verb{    }convolve(c(v,numeric(pow.2-n)),c(gtn(m-1,n),numeric(pow.2-n)),conj=F)[seq_len(n)] \cr
} \cr \cr
}
And this will compute the difference of \code{v} iterated \code{m} times: \cr \cr
\code{
bar <- function(v,m){ \cr
\verb{    }n <- length(v) \cr
\verb{    }pow.2 <- 2^(1+ceiling(log(n,2))) \cr
\verb{    }convolve(c(v,numeric(pow.2-n)),c(gtn(-(m+1),n),numeric(pow.2-n)),conj=F)[seq_len(n)] \cr
} 
} \cr \cr
The nth generalized triangular number in dimension z is
given by \code{1/(z*beta(n,z))}. However, the base R function \code{beta} does not
support arbitrary complex arguments.
}
